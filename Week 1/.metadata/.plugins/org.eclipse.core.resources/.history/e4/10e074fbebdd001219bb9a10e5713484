import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.TreeSet;

/**
 * 
 */

/**
 * @author jez.davies
 *
 */
public class BranchAndBoundKnapsackSolver extends KnapsackSolver {

	private List<Item> items;
	private TreeSet<Node> nodes;
	private int bestEstimate;
	
	/* (non-Javadoc)
	 * @see KnapsackSolver#solve(int, int, java.util.List)
	 */
	@Override
	protected Knapsack solve(int numberOfItemsIn, int capacityIn,
			List<Item> itemsIn) throws Exception {

		//store the parameters so they can be used throughout
		capacity = capacityIn;
		numberOfItems = numberOfItemsIn;
		items = itemsIn;
		
		//create the TreeSet that will hold our nodes - pass it a comparator
		nodes = new TreeSet<Node>(Node.descendingEstimateNodeComparator);

		
		//return the Knapsack with the optimum contents
		return getOptimumSack();
		
	}
	
	private Knapsack getOptimumSack()
	{
		//sort the items by their value/weight ratio
		Collections.sort(items, Item.descendingRatioItemComparator);
		
		//calculate the root node optimistic evaluation
		int rootOptimisticEvaluation = 0;
		for (Item i : items){
			rootOptimisticEvaluation += i.getValue();
		}
		
		//create root node
		nodes.add(new Node(0, capacity, rootOptimisticEvaluation, 0, new ArrayList<Integer>()));
		
		do{
			processNode(nodes.last());
		}while(nodes.size() > 2);

		//we now have the best node so create the corresponding knapsack
		return createKnapsackFromNode(nodes.last());
	}
	
	private void processNode(Node currentNode){
		//get the item that is next in the list
		int nextItemIndex = currentNode.getItemIndex()+1;
		Item nextItem = items.get(nextItemIndex);
		//create the child nodes for this node
		createPositiveNode(currentNode, nextItemIndex, nextItem);
		createNegativeNode(currentNode, nextItemIndex, nextItem);
		
		
		
		//now create the node that represents if we don't take the next item
		Node negativeNode = new Node(currentNode.getValue(), 
									 currentNode.getRoom(), 
									 currentNode.getEstimate() - nextItem.getValue(), 
									 nextItemIndex, 
									 new ArrayList<Integer>(currentNode.getItemIDs()));
	}

	private void createPositiveNode(Node currentNode, int nextItemIndex,
			Item nextItem) {
		//if we take the next item then we need to add it to the list of itemIDs for the 
				List<Integer> newItemIDsList = new ArrayList<Integer>(currentNode.getItemIDs());
				newItemIDsList.add(new Integer(nextItem.getItemNumber()));
				
				//now create the node that represents if we take the next item
				Node positiveNode = new Node(currentNode.getValue() + nextItem.getValue(),
											 currentNode.getRoom() - nextItem.getWeight(),
											 currentNode.getEstimate(), 
											 nextItemIndex, 
											 newItemIDsList);
		
	}
	

}
