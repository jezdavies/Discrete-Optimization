import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.TreeSet;

/**
 * 
 */

/**
 * @author jez.davies
 *
 */
public class BranchAndBoundKnapsackSolver extends KnapsackSolver {

	private List<Item> items;
	private TreeSet<Node> nodes;
	
	/* (non-Javadoc)
	 * @see KnapsackSolver#solve(int, int, java.util.List)
	 */
	@Override
	protected Knapsack solve(int numberOfItemsIn, int capacityIn,
			List<Item> itemsIn) throws Exception {

		//store the parameters so they can be used throughout
		capacity = capacityIn;
		numberOfItems = numberOfItemsIn;
		items = itemsIn;
		

		
		//return the Knapsack with the optimum contents
		return getOptimumSack();
		
	}
	
	private Knapsack getOptimumSack()
	{
		//sort the items by their value/weight ratio
		Collections.sort(items, Item.itemComparator);
		
		//calculate the root node optimistic evaluation
		int rootOptimisticEvaluation = 0;
		for (Item i : items){
			rootOptimisticEvaluation += i.getValue();
		}
		
		//create root node
		nodes.add(new Node(0, capacity, rootOptimisticEvaluation, 0, new ArrayList<Integer>()));
		
		do{
			processNode(nodes.last());
		}while(nodes.size() > 1);

		//we now have the best node so create the corresponding knapsack
		return createKnapsackFromNode(nodes.last());
	}
	
	private void processNode(Node currentNode){
		//get the item that is next in the list
		int nextItemIndex = currentNode.getItemIndex()+1;
		Item nextItem = items.get(nextItemIndex);
		//create the child nodes for this node
		//if we take the next item then we need to add it to the list of itemIDs for the 
		List<Integer> newItemIDList = new ArrayList<Item>(currentNode.getItemIDs());
		newItemIDList.add(new Integer(nextItem.getItemNumber()));
		Node positiveNode = new Node(currentNode.getValue() + nextItem.getValue(),
									 currentNode.getRoom() - nextItem.getWeight(),
									 currentNode.getEstimate(), nextItemIndex, currentNode.getItemIDs().);
		Node negativeNode = new 
	}
	

}
