import java.util.Collections;
import java.util.List;
import java.util.TreeSet;

/**
 * 
 */

/**
 * @author jez.davies
 *
 */
public class BranchAndBoundKnapsackSolver extends KnapsackSolver {

	private List<Item> items;
	private TreeSet<Node> nodes;
	
	/* (non-Javadoc)
	 * @see KnapsackSolver#solve(int, int, java.util.List)
	 */
	@Override
	protected Knapsack solve(int numberOfItemsIn, int capacityIn,
			List<Item> itemsIn) throws Exception {

		//store the parameters so they can be used throughout
		capacity = capacityIn;
		numberOfItems = numberOfItemsIn;
		items = itemsIn;
		

		
		//return the Knapsack with the optimum contents
		return getOptimumSack();
		
	}
	
	private Knapsack getOptimumSack()
	{
		//sort the items by their value/weight ratio
		Collections.sort(items, Item.itemComparator);
		
		//calculate the root node optimistic evaluation
		int rootOptimisticEvaluation = 0;
		for (Item i : items){
			rootOptimisticEvaluation += i.getValue();
		}
		
		//create root node
		nodes.add(new Node(0, capacity, rootOptimisticEvaluation));
		
		do{
			processNode(nodes.last());
		}while(nodes.size() > 1);

		
		
		
		
		Knapsack sack = new Knapsack(capacity);
		return sack;
	}
	

}
